--TODO Find out how to do delays, so animations and movement can look better

-- Player's health, inventory, and stats are dealt with in player_stats.script
go.property("x_move_distance", 128)
go.property("y_move_distance", 90.4)
go.property("player_damage", 2)

-- Pre-hashing ids improves performance
local input_up = hash("up")
local input_down = hash("down")
local input_left = hash("left")
local input_right = hash("right")
local input_action = hash("action")
local input_attack = hash("mouse_press")
local anim_run = hash("run_right")
local anim_idle = hash("idle_right")

--[[ Plays an animation ]]
local function play_animation(self, animation)
	-- Prevent same animation from starting over and over again
	if self.animation_playing ~= animation then
		msg.post("#sprite", "play_animation", {id = hash(animation)})
		self.animation_playing = animation
	end
end

-- [[ Sets animation based on action ]]
local function update_animations(self)
	if self.dir.x == 1 then
		play_animation(self, "idleRight")
	elseif self.dir.x == -1 then
		play_animation(self, "idleLeft")
	elseif self.dir.y == 1 then
		--play_animation(self, "idleUp")
		play_animation(self, "idleRight")
	elseif self.dir.y == -1 then
		-- play_animation(self, "idleDown")
		play_animation(self, "idleLeft")
	end 
end

-- Currently player turns are ended from moving and attacking
local function end_turn(self)
	self.player_turn = false
	msg.post("/battleController", "end_player_turn")
	pprint("battle_player.script: Player's turn is over.")
end

-- Cast a ray in the given direction to check for collision
local function cast_ray_from_player(self, distance, direction)
	local ray_distance = distance
	-- Add hashed groups to the table if you want to detect other collision groups
	local collision_groups = { hash("border"), hash("enemy") }

	local from = go.get_position()
	local to = go.get_position()
	to[direction] = to[direction] + ray_distance

	--pprint("battle_player.script: to ray cast: "..to)
	--pprint("battle_player.script: player_location: "..player_position)

	physics.ray_cast(from, to, collision_groups)
end

-- Checks for obstacles before allowing player to move and end their turn
local function try_moving(self, distance, direction)
	-- Set the move variables for if move is successful
	self.move_direction = direction
	self.move_distance = distance

	-- Check for collisions before moving player
	cast_ray_from_player(self, distance, direction)
end

-- Function for when player attacks by moving into an enemy
local function attack(self, enemy)
	play_animation(self, "attackRight")
	msg.post(enemy, "player_attack", { self.player_damage })
	end_turn(self)
end

-- Performs a one space move
local function move(self)
	self.player_position = go.get_position()
	
	local pos = go.get_position() 
	
	pos[self.move_direction] = pos[self.move_direction] + self.move_distance
	go.set_position(pos) 

	end_turn(self)
end

function init(self)
	msg.post(".", "acquire_input_focus")
	pprint(go.get_position())

	-- Sends current player location to message hub, so any script that needs to send 
	-- any messages to the current level game objects have the socket needed
	player_url = msg.url()
	msg.post("main:/controller#message_hub", "player_location", { player_url.socket })
	msg.post("main:/debugCommands", "in_battle")

	self.player_position = go.get_position() -- Position of player
	self.animation_playing = nil -- Checks if animation is playing
	self.dir = vmath.vector3(1, 0, 0) -- Keep direction of player

	self.move_distance = nil
	self.move_direction = nil

	self.player_turn = true
end


function update(self, dt)
	-- msg.post("camera", "look_at") Camera is childed to player, this can be used as part of persp camera
	--pprint("battle_player.script: currently player turn == "..tostring(self.player_turn))
end

function on_message(self, message_id, message, sender)
	-- For battle, can player leave? Or post a retreat message if player tries to leave door?
	if message_id == hash("trigger_response") then
		pprint(tostring(message.other_id).." triggered")
		msg.post(message.other_id, "player_entered")

	-- Stop player from moving and ending turn if their is a border in the way
	elseif message_id == hash("ray_cast_response") and message.group == hash("border") then
		pprint("battle_player.script: ray_cast dectected border, player movement stopped")
		pprint(message)

	-- Player has ran into an enemy, so attack the enemy
	elseif message_id == hash("ray_cast_response") and message.group == hash("enemy") then
		attack(self, message.id)

	-- Lets script know that the space ahead is clear and is good to move the player
	elseif message_id == hash("ray_cast_missed") then
		move(self)
		--print("battle_player.script: player is good to move")

	-- Sets player back to correct idle after attack animation
	elseif message_id == hash("animation_done") then 
		update_animations(self)

	elseif message_id == hash("enemy_turn_over") then
		self.player_turn = true
	end
end

function on_input(self, action_id, action)
	-- TODO Implement attack, either running into enemy or pressing an attack key (i.e. for invis enemies or otherwise)
	-- Player can only perform move and attack actions on turn
	if self.player_turn == true then
		if action_id == input_up and action.pressed then
			if self.dir.y == 1 then
				try_moving(self, self.y_move_distance, 'y')
			else
				-- Is this slower? 
				-- self.dir = vmath.vector3(0,1,0)
				self.dir.y = 1
				self.dir.x = 0
				update_animations(self)
			end
		elseif action_id == input_down and action.pressed then
			if self.dir.y == -1 then
				try_moving(self, (-self.y_move_distance), 'y')
			else
				self.dir.y = -1
				self.dir.x = 0
				update_animations(self)
			end
		elseif action_id == input_left and action.pressed then
			if self.dir.x == -1 then
				try_moving(self, (-self.x_move_distance), 'x') 
			else
				self.dir.x = -1
				self.dir.y = 0
				update_animations(self)
			end
		elseif action_id == input_right and action.pressed then
			if self.dir.x == 1 then
				try_moving(self, self.x_move_distance, 'x') 
			else
				self.dir.x = 1
				self.dir.y = 0
				update_animations(self)
			end
		end
	end

		-- TODO Move debug buttons and functions to their own script, maybe make a testing script if needed
		-- Debug button
	if action_id == hash("f1_press") and action.pressed then
		pprint("player.script:debug: Dealing 3 damage to player")
		msg.post(".", "damage_player", {damage = 3})
		--msg.post("main:/questHandler", "debug_quest_complete")
		--msg.post("main:/controller", "startBattle")

		-- Debug button #2 Add 1 of each item to the inventory
	elseif action_id == hash("f2_press") and action.pressed then
		self.player_turn = true
		pprint("battle_player.script: It is now player's turn")
	end

	--[[ Debug button #3 moves to the test battle level
	elseif action_id == hash("f3_press") and action.pressed then
		msg.post("main:/controller", "exit_battle")
	end]]
end