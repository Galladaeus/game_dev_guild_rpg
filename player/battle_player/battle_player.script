--TODO Find out how to do delays, so animations and movement can look better

go.property("x_move_distance", 128)
go.property("y_move_distance", 90.4)
go.property("player_damage", 2)

-- Pre-hashing ids improves performance
local input_up = hash("up")
local input_down = hash("down")
local input_left = hash("left")
local input_right = hash("right")
local input_action = hash("action")
local input_attack = hash("mouse_press")
local anim_run = hash("run_right")
local anim_idle = hash("idle_right")

local function move(self, distance, direction)
	self.player_position = go.get_position()
	local pos = go.get_position() 
	pos[direction] = pos[direction] + distance
	go.set_position(pos) 
end

--[[Don't need currently]]
-- Cast a ray in the given direction to check for collision
local function cast_ray_from_player(self, direction)
	local ray_distance = 128
	-- Add hashed groups to the table if you want to detect other collision groups
	local collision_groups = {hash("border")}

	local from = go.get_position()
	local to = go.get_position()
	to[direction] = to[direction] + ray_distance

	--[[
	pprint("battle_player.script: to ray cast: "..to)
	pprint("battle_player.script: player_location: "..player_position) ]]

	physics.ray_cast(from, to, collision_groups)
end

--[[ Plays an animation ]]
local function play_animation(self, animation)
	-- Prevent same animation from starting over and over again
	if self.animation_playing ~= animation then
		msg.post("#sprite", "play_animation", {id = hash(animation)})
		self.animation_playing = animation
	end
end

-- [[ Sets animation based on action ]]
-- Way too clunky, should to be updated
local function update_animations(self) end

function init(self)
	msg.post(".", "acquire_input_focus")
	pprint(go.get_position())

	-- Sends current player location to message hub, so any script that needs to send 
	-- any messages to the current level game objects have the socket needed
	player_url = msg.url()
	msg.post("main:/controller#message_hub", "player_location", { player_url.socket })

	self.player_position = go.get_position() -- Position of player
	self.animation_playing = nil -- Checks if animation is playing
	self.dir = vmath.vector3(0, 1, 0)

	-- Prevents the player from being moved back twice when trying to move into a border
	-- Do not know why the player gets moved back twice without it, something to do with
	-- how the messages are updated, for some reason, collision response is sent twice when
	-- player moves into a collision border
	-- Not necessarily needed for current way borders are set up but still prevents a double
	-- collision response which is useful
	self.moved_back = false
end


function update(self, dt)
	-- msg.post("camera", "look_at") Camera is childed to player, this can be used as part of persp camera
	local pos = go.get_position() 
	--pos = pos + self.vel * dt 
	--go.set_position(pos) 
	--update_animations(self)

	self.moved_back = false
end

function on_message(self, message_id, message, sender)
	-- For battle, can player leave? Or post a retreat message if player tries to leave door?
	if message_id == hash("trigger_response") then
		pprint(tostring(message.other_id).." triggered")
		msg.post(message.other_id, "player_entered")

	--[[
	elseif message_id == hash("ray_cast_response") then
		pprint("ray_cast dectected border")
		local pos = go.get_position() 
		pos.x = pos.x - 128
		go.set_position(pos) 
		--msg.post(".", "move_back")
	]]

	elseif message_id == hash("collision_response") and message.other_group == hash("enemy") then
		--pprint(message.other_group)
		if self.moved_back == false then
			--TODO Attack enemy!, should play a swipe animation and maybe an effect,
			--make enemy flash and take damage, then enemy gets to take turn
			go.delete(message.other_id)
			pprint("battle_player.script: You killed ["..message.other_id.."]")
			
			local pos = go.get_position() 
			pprint("Collision_response go.get_position() == "..pos)
			--pos.x = pos.x - 128
			go.set_position(self.player_position) 
			self.moved_back = true
		end
	end
end

function on_input(self, action_id, action)
	--TODO Change direction of sprite based on last direction moved
	if action_id == input_up and action.pressed then
		move(self, self.y_move_distance, 'y')
	elseif action_id == input_down and action.pressed then
		move(self, (-self.y_move_distance), 'y')
	elseif action_id == input_left and action.pressed then
		move(self, (-self.x_move_distance), 'x') 
	elseif action_id == input_right and action.pressed then
		move(self, self.x_move_distance, 'x') 
		--pprint("player moved to position:"..pos)

		--[[ ATTACK INPUT
	elseif action_id == input_attack and action.pressed then
		-- Calculate direction of attack, INCORRECT
		local angle = math.atan2(self.dir.y, self.dir.x)
		local rot = vmath.quat_rotation_z(angle)
		-- Move attack away from being directly on top of player
		local attackPos = vmath.vector3(100, 100, 0)

		local pos = go.get_position()
		local props = {dir = self.dir} -- unneeded
		factory.create("#attackFactory", pos + attackPos, rot, props, vmath.vector3(0.2, 0.2, 0.2))
		pprint("attacking")
		]]

		-- TODO Move debug buttons and functions to their own script, maybe make a testing script if needed
		-- Debug button
	elseif action_id == hash("f1_press") and action.pressed then
		pprint("player.script:debug: Dealing 3 damage to player")
		msg.post(".", "damage_player", {damage = 3})
		--msg.post("main:/questHandler", "debug_quest_complete")
		--msg.post("main:/controller", "startBattle")

		-- Debug button #2 Add 1 of each item to the inventory
	elseif action_id == hash("f2_press") and action.pressed then
		pprint("player.script:debug: Adding 1 of each item to inventory")
		msg.post("main:/inventory", "add_item", {"health_potion", 1})
		msg.post("main:/inventory", "add_item", {"damage_potion", 1})
		msg.post("main:/inventory", "add_item", {"throwable", 1})

		-- Debug button #3 moves to the test battle level
	elseif action_id == hash("f3_press") and action.pressed then
		msg.post("main:/controller", "exit_battle")
	end
end