--TODO Find out how to do delays, so animations and movement can look better

go.property("x_move_distance", 128)
go.property("y_move_distance", 90.4)
go.property("player_damage", 2)

-- Pre-hashing ids improves performance
local input_up = hash("up")
local input_down = hash("down")
local input_left = hash("left")
local input_right = hash("right")
local input_action = hash("action")
local input_attack = hash("mouse_press")
local anim_run = hash("run_right")
local anim_idle = hash("idle_right")

-- Currently player turns are ended from moving and attacking
local function end_turn(self)
	self.player_turn = false
	msg.post("/battleController", "end_player_turn")
end

-- Cast a ray in the given direction to check for collision
local function cast_ray_from_player(self, distance, direction)
	local ray_distance = distance
	-- Add hashed groups to the table if you want to detect other collision groups
	local collision_groups = {hash("border")}

	local from = go.get_position()
	local to = go.get_position()
	to[direction] = to[direction] + ray_distance

	--pprint("battle_player.script: to ray cast: "..to)
	--pprint("battle_player.script: player_location: "..player_position)

	physics.ray_cast(from, to, collision_groups)
end

-- Checks for obstacles before allowing player to move and end their turn
local function try_moving(self, distance, direction)
	-- Set the move variables for if move is successful
	self.move_direction = direction
	self.move_distance = distance

	-- Check for collisions before moving player
	cast_ray_from_player(self, distance, direction)
end

local function attack(self, distance, direction)
end

-- Performs a one space move
local function move(self)
	self.player_position = go.get_position()
	
	local pos = go.get_position() 
	
	pos[self.move_direction] = pos[self.move_direction] + self.move_distance
	go.set_position(pos) 

	end_turn(self)
end


--[[ Plays an animation ]]
local function play_animation(self, animation)
	-- Prevent same animation from starting over and over again
	if self.animation_playing ~= animation then
		msg.post("#sprite", "play_animation", {id = hash(animation)})
		self.animation_playing = animation
	end
end

-- [[ Sets animation based on action ]]
-- Way too clunky, should to be updated
local function update_animations(self)
	if self.dir.x == 1 then
		play_animation(self, "idleRight")
	elseif self.dir.x == -1 then
		play_animation(self, "idleLeft")
	elseif self.dir.y == 1 then
		--play_animation(self, "idleUp")
		play_animation(self, "idleRight")
	elseif self.dir.y == -1 then
		-- play_animation(self, "idleDown")
		play_animation(self, "idleLeft")
	end 
end

function init(self)
	msg.post(".", "acquire_input_focus")
	pprint(go.get_position())

	-- Sends current player location to message hub, so any script that needs to send 
	-- any messages to the current level game objects have the socket needed
	player_url = msg.url()
	msg.post("main:/controller#message_hub", "player_location", { player_url.socket })

	self.player_position = go.get_position() -- Position of player
	self.animation_playing = nil -- Checks if animation is playing
	self.dir = vmath.vector3(1, 0, 0) -- Keep direction of player

	self.move_distance = nil
	self.move_direction = nil

	self.player_turn = true

	-- Prevents the player from being moved back twice when trying to move into a border
	-- Do not know why the player gets moved back twice without it, something to do with
	-- how the messages are updated, for some reason, collision response is sent twice when
	-- player moves into a collision border
	-- MIGHT NOT NEED ANYMORE WITH WAY I AM NOW HANDLING RAYCASTS
	self.moved_back = false
end


function update(self, dt)
	-- msg.post("camera", "look_at") Camera is childed to player, this can be used as part of persp camera
	-- pos = pos + self.vel * dt 

	update_animations(self)
	self.moved_back = false

	pprint("battle_player.script: currently player turn == "..tostring(self.player_turn))
end

function on_message(self, message_id, message, sender)
	-- For battle, can player leave? Or post a retreat message if player tries to leave door?
	if message_id == hash("trigger_response") then
		pprint(tostring(message.other_id).." triggered")
		msg.post(message.other_id, "player_entered")

	-- Stop player from moving and ending turn if their is a border in the way
	elseif message_id == hash("ray_cast_response") and message.group == hash("border") then
		pprint("battle_player.script: ray_cast dectected border, player movement stopped")
		pprint(message)

	elseif message_id == hash("ray_cast_missed") then
		move(self)
		pprint("battle_player.script: player is good to move")

	-- Handle enemy collision and attack with ray_cast
	elseif message_id == hash("collision_response") and message.other_group == hash("enemy") then
		--pprint(message.other_group)
		if self.moved_back == false then
			--TODO Attack enemy!, should play a swipe animation and maybe an effect,
			--make enemy flash and take damage, then enemy gets to take turn
			go.delete(message.other_id)
			pprint("battle_player.script: You killed ["..message.other_id.."]")
			
			local pos = go.get_position() 
			pprint("Collision_response go.get_position() == "..pos)
			--pos.x = pos.x - 128
			go.set_position(self.player_position) 
			self.moved_back = true

			-- End turn TODO Move into a function that sends a message to all enemies?
			end_turn(self)
		end

	--[[ Border collisions are handles by ray cast
	elseif message_id == hash("collision_response") and message.other_group == hash("border") then
		if self.moved_back == false then
			local pos = go.get_position() 
			go.set_position(self.player_position) 
			self.moved_back = true

			pprint("player ran into object so it's still player turn")
			self.player_turn = true
		end
	]]

	elseif message_id == hash("enemy_turn_over") then
		self.player_turn = true
	end
end

function on_input(self, action_id, action)
	-- TODO Implement attack, either running into enemy or pressing an attack key (i.e. for invis enemies or otherwise)
	-- Player can only perform move and attack actions on turn
	if self.player_turn == true then
		if action_id == input_up and action.pressed then
			if self.dir.y == 1 then
				try_moving(self, self.y_move_distance, 'y')
			else
				-- Is this slower? 
				-- self.dir = vmath.vector3(0,1,0)
				self.dir.y = 1
				self.dir.x = 0
			end
		elseif action_id == input_down and action.pressed then
			if self.dir.y == -1 then
				try_moving(self, (-self.y_move_distance), 'y')
			else
				self.dir.y = -1
				self.dir.x = 0
			end
		elseif action_id == input_left and action.pressed then
			if self.dir.x == -1 then
				try_moving(self, (-self.x_move_distance), 'x') 
			else
				self.dir.x = -1
				self.dir.y = 0
			end
		elseif action_id == input_right and action.pressed then
			if self.dir.x == 1 then
				try_moving(self, self.x_move_distance, 'x') 
			else
				self.dir.x = 1
				self.dir.y = 0
			end
		end
	end

		--[[ ATTACK INPUT
	elseif action_id == input_attack and action.pressed then
		-- Calculate direction of attack, INCORRECT
		local angle = math.atan2(self.dir.y, self.dir.x)
		local rot = vmath.quat_rotation_z(angle)
		-- Move attack away from being directly on top of player
		local attackPos = vmath.vector3(100, 100, 0)

		local pos = go.get_position()
		local props = {dir = self.dir} -- unneeded
		factory.create("#attackFactory", pos + attackPos, rot, props, vmath.vector3(0.2, 0.2, 0.2))
		pprint("attacking")
		]]

		-- TODO Move debug buttons and functions to their own script, maybe make a testing script if needed
		-- Debug button
	if action_id == hash("f1_press") and action.pressed then
		pprint("player.script:debug: Dealing 3 damage to player")
		msg.post(".", "damage_player", {damage = 3})
		--msg.post("main:/questHandler", "debug_quest_complete")
		--msg.post("main:/controller", "startBattle")

		-- Debug button #2 Add 1 of each item to the inventory
	elseif action_id == hash("f2_press") and action.pressed then
		self.player_turn = true

		-- Debug button #3 moves to the test battle level
	elseif action_id == hash("f3_press") and action.pressed then
		msg.post("main:/controller", "exit_battle")
	end
end