-- Pre-hashing ids improves performance
local input_up = hash("up")
local input_down = hash("down")
local input_left = hash("left")
local input_right = hash("right")
local input_action = hash("action")
local input_attack = hash("mouse_press")
local anim_run = hash("run_right")
local anim_idle = hash("idle_right")

-- Temp function to print a table's data
local function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end

function init(self)
    msg.post(".", "acquire_input_focus")
    self.vel = vmath.vector3()     			-- Position of player
    self.anim = nil							-- Checks if animation is playing
    self.inrangeofnpc = false				-- Keep track if player is in range to start conversation
    --self.inBattle = false
    self.dir = vmath.vector3(0, 1, 0)
end

local function play_animation(self, anim)
	-- Don't collide animations
	if self.anim ~= anim then
		-- Code for spine model, need to change for a sprite atlas/ tilesource
		spine.play("#spinemodel", anim, go.PLAYBACK_LOOP_FORWARD, 0.1)
		self.anim = anim
	end
end

local function update_animations(self)
	-- Can use to flip a sprite around to make sure correct direction
	-- is being faced, not usable with spine yet
	-- sprite.set_hflip("#sprite", self.move_input < 0)
	
	-- Check if player isn't moving
	if (self.vel.x == 0 and self.vel.y == 0) then
		play_animation(self, anim_idle)
	else 
		play_animation(self, anim_run)
		end
end

function update(self, dt)
	-- msg.post("camera", "look_at") Camera is childed to player, this can be used as part of persp camera
    local pos = go.get_position() 
    pos = pos + self.vel * dt 
    go.set_position(pos) 
    update_animations(self)
    
    -- Used to send the conversation message to correct npc
    self.npc_address = nil
    
    self.vel.x = 0 
    self.vel.y = 0
    self.inrangeofnpc = false
end

function on_message(self, message_id, message, sender)
	-- print(sender)
	if message_id == hash("trigger_response") then
		pprint("Triggered")
	end
	if message_id == hash("contact_point_response") then
		if message.group == hash("npc") then -- TODO Should use collision response for npc, seperate later
			self.inrangeofnpc = true
			self.npc_address = message.other_id
		elseif message.group == hash("border") then
			local newpos = go.get_position() + message.normal * message.distance	-- Seperate player and collision so player cannot enter
			go.set_position(newpos)
		end
	end
end

function on_input(self, action_id, action)
    if action_id == input_up then
        self.vel.y = 300 
    elseif action_id == input_down then
        self.vel.y = -300
    elseif action_id == input_left then
        self.vel.x = -300 
    elseif action_id == input_right then
        self.vel.x = 300
    elseif action_id == input_attack and action.pressed then
    	--calculate direction of attack
    	local angle = math.atan2(self.dir.y, self.dir.x)
    	local rot = vmath.quat_rotation_z(angle)
    	--move attack away from being directly on top of player
    	local attackPos = vmath.vector3(100, 100, 0)
    	local pos = go.get_position()
		local props = {dir = self.dir} -- unneeded
    	factory.create("#attackFactory", pos --[[+ attackPos]], rot, props, vmath.vector3(0.2, 0.2, 0.2))
    	print("attacking")
    elseif action_id == input_action and self.inrangeofnpc == true and action.pressed then	-- action.pressed prevents button from being pushed multiple times in one press
    	
		msg.post(self.npc_address, "chat")
    	print("sent")
    elseif action_id == hash("f1_press") and action.pressed then
    	msg.post("main:/controller", "startBattle")
    	msg.post("main:/controller", "unloadTown")
    end
    
    -- normalize direction to NESW
    if vmath.length(self.vel) > 0 then
    	self.moving = true
    	self.dir = vmath.normalize(self.vel)
    end
end