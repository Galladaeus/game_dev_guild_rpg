-- Pre-hashing ids improves performance
local input_up = hash("up")
local input_down = hash("down")
local input_left = hash("left")
local input_right = hash("right")
local input_action = hash("action")
local input_attack = hash("mouse_press")
local anim_run = hash("run_right")
local anim_idle = hash("idle_right")

-- Temp function to print a table's data
local function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end
  
--[[ Plays an animation ]]
local function play_animation(self, animation)
	-- Prevent same animation from starting over and over again
	if self.animation_playing ~= animation then
		-- Code for spine model, need to change for a sprite atlas/ tilesource
		spine.play("#spinemodel", animation, go.PLAYBACK_LOOP_FORWARD, 0.1)
		self.animation_playing = animation
	end
end

local function update_animations(self)
	-- Can use to flip a sprite around to make sure correct direction
	-- is being faced, not usable with spine yet
	-- sprite.set_hflip("#sprite", self.move_input < 0)
	
	-- Check if player isn't moving
	if (self.vel.x == 0 and self.vel.y == 0) then
		play_animation(self, anim_idle)
	else 
		play_animation(self, anim_run)
		end
end

function init(self)
    msg.post(".", "acquire_input_focus")

    self.vel = vmath.vector3()     			-- Position of player
    self.animation_playing = nil							-- Checks if animation is playing
    self.inrangeofnpc = false				-- Keep track if player is in range to start conversation
    --self.inBattle = false
    self.dir = vmath.vector3(0, 1, 0)
end


function update(self, dt)
	-- msg.post("camera", "look_at") Camera is childed to player, this can be used as part of persp camera
    local pos = go.get_position() 
    pos = pos + self.vel * dt 
    go.set_position(pos) 
    update_animations(self)
    
    -- Used to send the conversation message to correct npc
    self.npc_address = nil
    
    self.vel.x = 0 
    self.vel.y = 0
    self.inrangeofnpc = false
end

function on_message(self, message_id, message, sender)
	-- If player enters a door
	if message_id == hash("trigger_response") then
		pprint(tostring(message.other_id).." triggered")
		msg.post(message.other_id, "player_entered")
	end
	
	if message_id == hash("contact_point_response") then
		if message.group == hash("npc") then -- TODO Should use collision response for npc, seperate later
			self.inrangeofnpc = true
			self.npc_address = message.other_id
		elseif message.group == hash("border") then
			local newpos = go.get_position() + message.normal * message.distance	-- Seperate player and collision so player cannot enter
			go.set_position(newpos)
		end
	end
	
end

function on_input(self, action_id, action)
    if action_id == input_up then
        self.vel.y = 300 
    elseif action_id == input_down then
        self.vel.y = -300
    elseif action_id == input_left then
        self.vel.x = -300 
    elseif action_id == input_right then
        self.vel.x = 300
    --[[ ATTACK INPUT
	elseif action_id == input_attack and action.pressed then
    	-- Calculate direction of attack, INCORRECT
    	local angle = math.atan2(self.dir.y, self.dir.x)
    	local rot = vmath.quat_rotation_z(angle)
    	-- Move attack away from being directly on top of player
    	local attackPos = vmath.vector3(100, 100, 0)
    	
    	local pos = go.get_position()
		local props = {dir = self.dir} -- unneeded
    	factory.create("#attackFactory", pos + attackPos, rot, props, vmath.vector3(0.2, 0.2, 0.2))
    	pprint("attacking")
    ]]
	-- Using action.pressed prevents button from registering multiple presses from one key press
    elseif action_id == input_action and self.inrangeofnpc == true and action.pressed then
		msg.post(self.npc_address, "start_conversation")
		
	-- testing button
	elseif action_id == hash("f1_press") and action.pressed then
		pprint("Pressed F1")
		msg.post("main:/questHandler", "debug_quest_complete")
    	--msg.post("main:/controller", "startBattle")
    end
    
    -- Normalize direction to NESW
    if vmath.length(self.vel) > 0 then
    	self.moving = true
    	self.dir = vmath.normalize(self.vel)
    end
end