-- Pre-hashing ids improves performance
local input_up = hash("up")
local input_down = hash("down")
local input_left = hash("left")
local input_right = hash("right")
local input_action = hash("action")
local anim_run = hash("run_right")
local anim_idle = hash("idle_right")

function init(self)
    msg.post(".", "acquire_input_focus")
    self.vel = vmath.vector3()     			-- Position of player
    self.anim = nil							-- Checks if animation is playing
    self.inrangeofnpc = false				-- Keep track if player is in range to start conversation
end

local function play_animation(self, anim)
	-- Don't collide animations
	if self.anim ~= anim then
		-- Code for spine model, need to change for a sprite atlas/ tilesource
		spine.play("#spinemodel", anim, go.PLAYBACK_LOOP_FORWARD, 0.1)
		self.anim = anim
	end
end

local function update_animations(self)
	-- Can use to flip a sprite around to make sure correct direction
	-- is being faced, not usable with spine yet
	-- sprite.set_hflip("#sprite", self.move_input < 0)
	
	-- Check if player isn't moving
	if (self.vel.x == 0 and self.vel.y == 0) then
		play_animation(self, anim_idle)
	else 
		play_animation(self, anim_run)
		end
end

function update(self, dt)
	-- msg.post("camera", "look_at") Camera is childed to player, this can be used as part of persp camera
    local pos = go.get_position() 
    pos = pos + self.vel * dt 
    go.set_position(pos) 
    update_animations(self)
    
    self.vel.x = 0 
    self.vel.y = 0
    self.inrangeofnpc = false
end

function on_message(self, message_id, message, sender)
	-- print(sender)
	if message_id == hash("contact_point_response") then
		if message.group == hash("npc") then -- TODO Should use collision response for npc, seperate later
	 		--print(sender)
	 		self.inrangeofnpc = true
	 	elseif message.group == hash("border") then
	 		local newpos = go.get_position() + message.normal * message.distance	-- Seperate player and collision so player cannot enter
	 		go.set_position(newpos)
	 		-- pprint("Hit border")
	 	end
	end
end

function on_input(self, action_id, action)
    if action_id == hash(input_up) then
        self.vel.y = 300 
    elseif action_id == hash(input_down) then
        self.vel.y = -300
    elseif action_id == hash(input_left) then
        self.vel.x = -300 
    elseif action_id == hash(input_right) then
        self.vel.x = 300
    elseif (action_id == hash(input_action) and self.inrangeofnpc == true and action.pressed) then	-- action.pressed prevents button from being pushed multiple times in one press
    	msg.post("goblin#script", "chat")
    	print("sent")
    end
end