local map_data = require "levels/town/outside/map/farmLand"

-- NOTE: The scripts for this single map are seperated into two because when combining the images of both
-- tilesets into one atlas it creates a heap overflow error and you cannot build, must keep atlases smaller
-- than ~8000x8000 appx, so either the individual tiles must be reduced in size, or the atlases have to be split,
-- leading to duplication

-- Reads data from a .lua script generated by tiled and using the tilesets table (in this case 
-- farmLand.lua which is renamed to map_data in this file, the script matches the id in the tileset
-- tile with the data in the layers section of the map_data to find the correct tile to draw and then 
-- sends that data to the newly created tile, this prevents the need to have the new tile have its' own script

-- Gets the tile data for number in layers[layer_number].data[data_iter]
local function get_tile_data(self)
	if self.draw_data[self.data_iter] > self.second_tileset_tilecount then
		if self.draw_data[self.data_iter] == 0 then
			return false 
		end
		for i,v in ipairs(self.second_tileset_tiles) do 
			-- Adds the number of tiles that are in the first set to the second set in order to generate
			-- the correct tiles to spawn
			if (v.id + map_data.tilesets[2].firstgid) == self.draw_data[self.data_iter] then
				pprint("map_farm.script:Changing tile to "..v.image) 
				self.tile_to_draw = v.image
				return true
			end
		end
	else
		pprint("map_overworld_tiles.script: Tile not contained in this tileset")
		return false
	end
	pprint("map_farm.script: Unable to find tile???")
end

function init(self)
	-- How many tiles are in the tileset being drawn by this script
	self.second_tileset_tilecount = map_data.tilesets[2].tilecount
	-- Tile information
	self.second_tileset_tiles = map_data.tilesets[2].tiles

	-- The tile image to draw
	self.tile_to_draw = nil

	-- Basic info to calculate map
	local tile_width = map_data.tilewidth
	local tile_height = map_data.tileheight + 20
	local map_width = map_data.width
	local map_height = map_data.height

	local map_size = vmath.vector3(tile_width * map_width, tile_height * map_height, 0) -- Total size of map, needed to calculate collision borders
	local pos = vmath.vector3(0, 0, 0) -- Start of isometric grid
	local screen_pos = vmath.vector3(0, 0, 0) -- Top left of grid for isometric grid

	-- Handle all the layers
	self.layer_iter = 1
	self.total_layers = 3

	-- Data of what to draw, make sure to label different animations 1, 2, 3...
	self.draw_data = map_data.layers[self.layer_iter].data
	self.data_iter = 1

	--[[for i, p in ipairs(drawData) do -- Print tile numbers to console
		print(p)
		end]]

	-- Table to contain tile's and collision border
	self.tile_map = {}
	self.border = {}
	
	--Draw the tiles layer by layer
	while self.layer_iter ~= self.total_layers do 
		self.data_iter = 1
		self.draw_data = map_data.layers[self.layer_iter].data
		for i = 1, map_width do
			for j = 1, map_height do
				-- Draw row of blocks
				-- Only create a tile if it is in the range of this tileset
				if get_tile_data(self) then
					pprint(self.tile_to_draw)
					-- Keep the id in order to send the tile draw data to the newly created title
					local id = factory.create("#overworldTileFactory", screen_pos, nil)
					msg.post(msg.url(nil, id, "sprite"), "play_animation", { id = hash(self.tile_to_draw) })
				end
				self.data_iter = self.data_iter + 1
				screen_pos.x = screen_pos.x + (tile_width/2)
				screen_pos.y = screen_pos.y - (tile_height/2)
				-- screen_pos.z = screen_pos.z + .00001 -- Since map is drawn from top left - down there is no need to touch z-axis
			end	
			-- Move on to next column of tiles to draw
			screen_pos.x = (pos.x) - (tile_width/2) * i
			screen_pos.y = (pos.y) - (tile_height/2) * i
			-- screen_pos.z = screen_pos.z + .00001 * i
		end
		-- Reset the draw position and move up the z-axis in order to draw on top of previous layers
		screen_pos.x = pos.x
		screen_pos.y = pos.y
		screen_pos.z = screen_pos.z + .0001

		self.layer_iter = self.layer_iter + 1
		pprint("map_overworld_tiles.script: New_layer: "..self.layer_iter)
	end
end