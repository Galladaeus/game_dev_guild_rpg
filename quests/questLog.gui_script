local questDescription
local questTitle
local questGiverTitle

local function populateQuestTable(self, questTable) -- Function to use when loading quest data?
	i = 0
end

function init(self)
	gui.set_enabled(gui.get_node("questLog"), false)
	gui.set_enabled(gui.get_node("questDescriptionBox"), false)
	
	questDescription = gui.get_node("questDescription")
	questTitle = gui.get_node("questTitle")
	questGiverTitle = gui.get_node("questGiverTitle")
end

function on_message(self, message_id, message, sender)
    if message_id == hash("openQuestLog") then
    	gui.set_enabled(gui.get_node("questLog"), true)
    	msg.post(".", "acquire_input_focus")
    elseif message_id == hash("questData") then	-- Receive questdata from conversationUIscript when a quest is accepted
    	local questData = message				 -- place into table and update data in questlog					
    	gui.set_text(questDescription, questData.questDescription[1])		-- TODO place all quest data into a single node that can be deleted
    	gui.set_text(questTitle, questData.questTitle[1])					-- once the quest is completed or moved to a quests completed area
    	gui.set_text(questGiverTitle, questData.questGiver[1])				-- send msg from questData.go once quest is completed
    	gui.set_text(gui.get_node("testQuest"), questData.questTitle[1])	-- ALSO need to make it so it can read more than one quest if loading or put into different message
    end
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_press") and action.pressed then
		local x = action.x
		local y = action.y
				
		if gui.pick_node(gui.get_node("testQuest"), x, y) then   
			gui.set_enabled(gui.get_node("questDescriptionBox"), true)
			
		elseif gui.pick_node(gui.get_node("backButton"), x, y) then	-- exit out of questLog, go back to main menu
			gui.set_enabled(gui.get_node("questDescriptionBox"), false)
			gui.set_enabled(gui.get_node("questLog"), false)
			msg.post(".", "release_input_focus")
			msg.post("playerMenu", "menuButton")
		end
	end
	
	return true
end