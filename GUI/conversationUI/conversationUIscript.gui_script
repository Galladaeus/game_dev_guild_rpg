-- TODO Completely refactor conversation system
local conversationTable = {}
local dialogUI
local playerChoice1
local playerChoice2
local playerChoice3
local playerChoice4
local npcText
local npcURL

local textIterator = 1 -- Contains number of text messages left to send to convo box

function init(self)
    dialogUI = gui.get_node("conversationUI")
    playerChoice1 = gui.get_node("player_choice_1")
    playerChoice2 = gui.get_node("player_choice_2")
    playerChoice3 = gui.get_node("player_choice_3")
    playerChoice4 = gui.get_node("player_choice_4")
    npcText = gui.get_node("npcText")
    gui.set_enabled(dialogUI, false)
end

local function closeUI()
	msg.post(".", "release_input_focus")
	gui.set_enabled(dialogUI, false)	 
	textIterator = 1
end

local function disableChoiceButtons()
	gui.set_enabled(playerChoice1, false)
	gui.set_enabled(playerChoice2, false)
	gui.set_enabled(playerChoice3, false)
	gui.set_enabled(playerChoice4, false)
end

local function showPlayerChoices(conversationTable)	-- Called to reset to start of conversation
	disableChoiceButtons()
	textIterator = 1
    local choiceIterator = 1
    local nodeIterator = 1
    while conversationTable.playerChoice[choiceIterator] do
    	gui.set_enabled(gui.get_node("player_choice_"..nodeIterator), true)
		gui.set_text(gui.get_node("choice"..nodeIterator), conversationTable.playerChoice[choiceIterator])
		nodeIterator = nodeIterator + 1
		choiceIterator = 2 + choiceIterator
   	end
end

local function playNPCtext(conversationTable, textChoice, textIterator)
	gui.set_text(gui.get_node("hubButtonText"), "Return")
	disableChoiceButtons()
	if (conversationTable.playerChoice[2*textChoice][textIterator] ~= nil) then
		gui.set_enabled(gui.get_node("player_choice_"..textChoice), true)
		gui.set_text(gui.get_node("choice"..textChoice),"Continue")
    	gui.set_text(gui.get_node("npcText"), conversationTable.playerChoice[2*textChoice][textIterator])
	elseif(conversationTable.playerChoice[2*textChoice].playerAnswer ~= nil) then
		gui.set_enabled(gui.get_node("player_choice_1"), true)
		gui.set_text(gui.get_node("choice1"), conversationTable.playerChoice[2*textChoice].playerAnswer[1])
		gui.set_enabled(gui.get_node("player_choice_2"), true)
		gui.set_text(gui.get_node("choice2"), conversationTable.playerChoice[2*textChoice].playerAnswer[2])
	else 
		closeUI()
	end
	textIterator = textIterator + 1
	return textIterator
end

function on_message(self, message_id, message, sender)
    if message_id == hash("NPCConversation") then
		-- Get conversation data from NPC go
  	  conversationTable = message
    	
    	-- Show dialogUI and take put input on top of input stack, set on_input to return true to eat all input
    	msg.post(".", "acquire_input_focus")
    	
    	-- Set up dialogUI to be ready for player input
    	gui.set_text(gui.get_node("npcText"), conversationTable.npcGreeting[1])
    	gui.set_enabled(dialogUI, true)
    	gui.set_text(gui.get_node("hubButtonText"), "GoodBye")
    	
    	-- Set up initial player choices
		showPlayerChoices(conversationTable)
		
		-- Get NPCAdress to send messages to
		npcURL = sender
		print(npcURL)
	end
end

function on_input(self, action_id, action)
	if action_id == hash("mouse_press") and action.pressed then	
		-- data to read button press
		local x = action.x
		local y = action.y
		local returnButton = gui.get_node("hubButton")	
		local returnButtonText = gui.get_node("hubButtonText")
		
		if gui.pick_node(returnButton, x, y) then
			if gui.get_text(returnButtonText) == "GoodBye" then
				closeUI()
			else
				gui.set_text(npcText, conversationTable.hubReturn)
				showPlayerChoices(conversationTable)
				gui.set_text(returnButtonText, "GoodBye")
			end			
		elseif gui.pick_node(playerChoice1, x, y) then
			if gui.get_text(gui.get_node("choice1")) == conversationTable.questTable.questAnswer[1] then
				pprint("Quest Accepted")
				-- PLAYER ACCEPTS QUEST; Send quest table to log and questData
				msg.post("main:/questData", "questData", conversationTable.questTable.questData)
				-- let NPC know quest has been accepted
				msg.post(npcURL, "quest_accepted")
				closeUI()
			end
			textIterator = playNPCtext(conversationTable, 1, textIterator)			
   	 elseif gui.pick_node(playerChoice2, x, y) then
   		if gui.get_text(gui.get_node("choice2")) == conversationTable.questTable.questAnswer[2] then
   			closeUI()
   		end
			textIterator = playNPCtext(conversationTable, 2, textIterator)		
 	   elseif gui.pick_node(playerChoice3, x, y) then
			textIterator = playNPCtext(conversationTable, 3, textIterator)		
    	elseif gui.pick_node(playerChoice4, x, y) then
			textIterator = playNPCtext(conversationTable, 4, textIterator)
    	end
	end

	-- As long as input is being listened to i.e. "true" it will consume input and
	-- controls are disabled for player character
    return true
end